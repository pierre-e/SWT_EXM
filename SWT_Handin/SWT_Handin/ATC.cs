///////////////////////////////////////////////////////////
//  ATC.cs
//  Implementation of the Class ATC
//  Generated by Enterprise Architect
//  Created on:      18-jun-2014 01:25:56
//  Original author: Pierre
///////////////////////////////////////////////////////////


using System;
using System.Collections.Generic;
using System.Timers;
using System.Xml;

namespace SWT_Handin
{
    public class ATC
    {
        public readonly int AreaHeight;
        public readonly int AreaWidth;
        public readonly int CollisionDist;
        public readonly int NearMissDist;
        private ITrackRenderer _trackRenderer;
        private IEventRenderer _eventRenderer;
        private Timer _timer;
        private int _tickTime;
        public readonly List<ITrack> _tracks = new List<ITrack>();
        private EventHandler eventHandler;

        public ATC()
        {
            CollisionDist = 100;
            NearMissDist = 5000;
            AreaHeight = 100000;
            AreaWidth = 100000;
            _tickTime = 250;
            InitTimer(250);
            _trackRenderer = new TrackRendererFile("TrackRendition.txt");
            _eventRenderer = new EventRendererConsol();
            eventHandler = new EventHandler(this);
        }

        public ATC(int areaHeight, int areaWidth, int collisionDist, int nearMissDist, ITrackRenderer trackRenderer,
            IEventRenderer eventRenderer, int tickTimer)
        {
            AreaHeight = areaHeight;
            AreaWidth = areaWidth;
            CollisionDist = collisionDist;
            NearMissDist = nearMissDist;
            _trackRenderer = trackRenderer;
            _eventRenderer = eventRenderer;
            eventHandler = new EventHandler(this);
            InitTimer(tickTimer);
            _tickTime = tickTimer;
        }
        private void InitTimer(int tickTime)
        {
            _timer = new Timer();
            _timer.Elapsed += Tick;
            _timer.Interval = tickTime; 
            _timer.Enabled = true;
            GC.KeepAlive(_timer);
        }


        /// <param name="track"></param>
        public void AcceptIncomingTrack(ITrack track)
        {
            _tracks.Add(track);
        }

        /// <param name="track"></param>
        public void HandOff(ITrack track)
        {
            _tracks.Remove(track);
        }

        public void Tick(object source, ElapsedEventArgs e)
        {
            _timer.Enabled = false;
            foreach (var track in _tracks)
            {
                track.Tick(_tickTime);
            }
            var listOfEventList = eventHandler.DetectEvents(_tracks);
            foreach (var eventList in listOfEventList)
            {
                foreach (var @event in eventList)
                {
                    _eventRenderer.Log(@event);
                }
            }
            _trackRenderer.RenderTracks(_tracks);
            _timer.Enabled = true;
        }

        public ATC(string filename)
    {
        var xDoc = new XmlDocument();
        // try
       // {
            xDoc.Load(filename);

      //  }
        //   catch (notfo)
    //    {
            
    //    }

        var element = xDoc.DocumentElement;

        var xpos = element.GetElementsByTagName("gridsizeX").Item(0);
        var ypos = element.GetElementsByTagName("gridsizeY").Item(0);
        var update = element.GetElementsByTagName("updateFrequency").Item(0);
        var nmRadius = element.GetElementsByTagName("nearMissRadius").Item(0);
        var atDistination = element.GetElementsByTagName("AtDistinationRadius").Item(0);

        if (xpos != null) AreaWidth = int.Parse(xpos.InnerText);
        if (ypos != null) AreaHeight = int.Parse(ypos.InnerText);
        if (update != null) _tickTime = int.Parse(update.InnerText);
        if (nmRadius != null) NearMissDist = int.Parse(nmRadius.InnerText);
        if (atDistination != null) CollisionDist = int.Parse(atDistination.InnerText);

        var render = element.GetElementsByTagName("rendererType").Item(0);
        string renderer;

        if (render== null)
        {
            renderer = "Console";
        }
        else
        {
            renderer = render.InnerText;
        }
        
        switch (renderer)
        {
            case "Console":
                _eventRenderer = new EventRendererConsol();
                break;
            case "File":
                //_eventRenderer = new Renderer(new EventRendererFile("render.txt"));
                break;
            default:
                _eventRenderer = new EventRendererConsol();
                break;
        }


        var consoleType = element.GetElementsByTagName("loggerType").Item(0);
        string consoleTypeJa;

        if (consoleType == null)
        {
            consoleTypeJa = "Console";
        }
        else
        {
            consoleTypeJa = consoleType.InnerText;
        }

        switch (consoleTypeJa)
        {
            case "Console":
                //_log = new ConsolLog();
                break;
            case "File":
                _trackRenderer = new TrackRendererFile("log.txt");
                break;
            default:
               // _log = new ConsolLog();
                break;
        }

    } //end ATC
} //end namespace Implementation